import xml.etree.ElementTree as ElementTree
import sys
import re
import csv
import datetime

# in this case we don't care if they share a numbering system - although we somewhat presume the numbers make sense (haha)
peripheralInheritence = {} 


#find peripherals which can be treated as smaller peripherals - e.g. USART/UART
with open(sys.argv[1], newline='') as csvfile:
   reader = csv.reader(csvfile, delimiter='\t')
   for row in reader:
      if(len(row)>1):
         rest = []
         for i in range(2, len(row)):
            rest.append(row[i])
         peripheralInheritence[row[0]] = rest
         

targets = ElementTree.parse(sys.argv[2]).getroot()
matchers = []
defFiles = []
for i in range(3, len(sys.argv)):
   nameMatch = re.search('(STM32[^_.]*)\\)?[^.x)]x', sys.argv[i]).expand('\\1')
   emptyBracket = re.search('(.*)\\((.*)', nameMatch)
   if(emptyBracket):
      others = emptyBracket.expand('\\2').replace("-", "")
      nameMatch = emptyBracket.expand('\\1')+"["+others+"]"
   nameMatch += '.x.*'
   matchers.append(nameMatch)
   defFiles.append(sys.argv[i])
   
index = 0; #This is a performance improvement on the n^2 comparison of the strings...

def basicVersionTrim(version):
   if(re.search(r"[^0-9_]((\d*_)*v\d+)", version)):
      return re.sub("_\d*_", "_", re.search(r"[^0-9_]((\d*_)*v\d+)", version).group(1)).replace("_v", "v")
   elif(re.match(r"^v(\d+)\.(\d+)", version)):
      return re.sub(r"^v(\d+)\.(\d+).*", "\\1v\\2", version)
   elif(re.match(r"^v(\d+)_(\d*)", version)):
      return re.sub(r"^v(\d+)_(\d*).*", "\\1v\\2", version)
   else:
      return "No valid version number found"

names = set()


for mcu in targets.iter("{http://st.com/stm32TargetDefinitions}mcu"):
   fullName = mcu.find("{http://st.com/stm32TargetDefinitions}name").text
   outputName = re.search('(.*).x.*', fullName).expand('\\1')
   pinFileName = re.search('(.*)..x.*', fullName).expand('\\1')
   names.add(outputName)
   flashSize = ""
   
   mems = mcu.find("{http://st.com/stm32TargetDefinitions}memories")
   for mem in mems.findall("{http://st.com/stm32TargetDefinitions}memory"):
      if(mem.find("{http://st.com/stm32TargetDefinitions}name").text == "FLASH"):
         flashSize = mem.find("{http://st.com/stm32TargetDefinitions}size").text
         break
   if(flashSize == ""):
      print("WARNING: no flash size found for "+outputName)
      continue
   mcuFile = ""
   for i in range(index-10, len(matchers)):
      if(re.search(matchers[i], fullName)):
         mcuFile = defFiles[i]
         index = i
         break;
   if(mcuFile == ""):
      for i in range(0, index-10):
         if(re.search(matchers[i], fullName)):
            mcuFile = defFiles[i]
            index = i
            break;
   if(mcuFile == ""):
      print("WARNING: no mcu file found for "+outputName)
      continue
   mcuRoot = ElementTree.parse(mcuFile).getroot()
   gpioSetup = ""
   
   systemVersions = {}
   systemCounts = {}
   
   for setup in mcuRoot.iter("{http://mcd.rou.st.com/modules.php?name=mcu}IP"):
      name = setup.get("Name")
      if(name == "GPIO"):
         if(gpioSetup != ""):
            print("WARNING: two GPIO setups found for "+outputName)
         gpioSetup = setup.get("Version").split("_")[0]
         
      if(name == "UCPD"):
         name = "USBC_PD"
      systemVersions[name] = basicVersionTrim(setup.get("Version"))
      if(not name in systemCounts):
         systemCounts[name] = 0
      systemCounts[name] += 1
      if(name in peripheralInheritence):
         for alt in peripheralInheritence[name]:
            if(not alt in systemCounts):
               systemCounts[alt] = 0
            if(not alt in systemVersions):
               systemVersions[alt] = basicVersionTrim(setup.get("Version")) # FIXME: ASSUMES THAT THE VERSIONS FOR e.g. USARTS CORRESPOND TO VERSIONS OF UART
            systemCounts[alt] += 1
       
  
   
   if(gpioSetup == ""):
      print("WARNING: no GPIO setup found for "+outputName)
   with open(outputName+".h", "w") as out:
      out.write("/*\n * This file is automatically generated by setup.py from the xml descriptions provided as part of the STM32Cube IDE\n")
      out.write(" * Timestamp: "+datetime.datetime.utcnow().isoformat()+"\n")
      out.write(" */\n\n")
      
      out.write("#ifndef LOWLEVEL_INCLUDE_DEVICE_SETUP\n")
      out.write("#define LOWLEVEL_INCLUDE_DEVICE_SETUP\n")
      out.write("#include <zscript/stm32/devices/stm32Setup.h>\n")
      out.write("#include <zscript/stm32/devices/Pins/"+pinFileName+".h>\n")
      out.write("#include <zscript/stm32/devices/AlternateFunction/"+gpioSetup+".h>\n\n")
      
      out.write("#ifndef ZSCRIPT_IDENTIFY_PLATFORM_HARDWARE_STRING\n")
      out.write("#define ZSCRIPT_IDENTIFY_PLATFORM_HARDWARE_STRING  \"ARM "+outputName+"\"\n")
      out.write("#endif\n\n")
      
      out.write("#define FLASH_SIZE "+flashSize+"\n\n")
      for name in ["I2C", "ADC", "DMA", "SPI", "UART", "USART", "LPUART", "USBC_PD", "USB", "DAC", "CAN"]:
         if(name in systemCounts):
            out.write("#define "+name+"_LL_STM32_Ver_"+systemVersions[name]+"\n")
            out.write("#define "+name+"_COUNT "+str(systemCounts[name])+"\n\n")

      
      out.write("\n#endif /* LOWLEVEL_INCLUDE_DEVICE_PINS */")
      

