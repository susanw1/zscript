import xml.etree.ElementTree as ElementTree
import sys
import csv
import re


peripheralInheritenceInject = {} # peripherals which share a numbering system
peripheralInheritenceIncrement = {} # peripherals which don't

#find peripherals which can be treated as smaller peripherals - e.g. USART/UART
with open(sys.argv[1], newline='') as csvfile:
   reader = csv.reader(csvfile, delimiter='\t')
   for row in reader:
      if(len(row)>1):
         rest = []
         for i in range(2, len(row)):
            rest.append(row[i])
         if(row[1] == "inj"):
            peripheralInheritenceInject[row[0]] = rest
         else:
            peripheralInheritenceIncrement[row[0]] = rest
         


for i in range(2, len(sys.argv)):
   functions = set()
   tree = ElementTree.parse(sys.argv[i])
   root = tree.getroot()
   for signal in root.iter("{http://mcd.rou.st.com/modules.php?name=mcu}PinSignal"):
      functions.add(signal.get("Name"));

   functionChildren = {}
   
   # add peripherals which do share numbering systems
   extraFuncs = set()
   for func in sorted(functions):
      functionChildren[func] = set()
      strFuncName = re.search('^[^\d]+', func).group(0)
      if(strFuncName in peripheralInheritenceInject):
         for alt in peripheralInheritenceInject[strFuncName]:
            newFunc = alt+re.search('\d.*', func).group(0)
            extraFuncs.add(newFunc)
            functionChildren[func].add(newFunc)
   functions |= extraFuncs
   
   for func in extraFuncs:
      if(not func in functionChildren):
         functionChildren[func] = set()
         

         
         
   highestByType = {} # the highest label of each peripheral type 
   for func in functions:
      plainName = re.search('^[^\d]+', func).group(0)
      match = re.search('\d+', func)
      if(match):
         number = int(match.group(0))
         if((not plainName in highestByType) or number > highestByType[plainName]):
            highestByType[plainName] = number
   
   # Then add peripherals which don't share numbering
   functionInjectNumberMap = {} # preserves the numbering for given original peripherals
   extraFuncs = set()
   for func in sorted(functions):
      strFuncName = re.search('^[^\d]+', func).group(0)
      match = re.search('\d+', func)
      if(match and (strFuncName in peripheralInheritenceIncrement)):
         origNumber = match.group(0)
         for alt in peripheralInheritenceIncrement[strFuncName]:
            if (not alt in functionInjectNumberMap):
               functionInjectNumberMap[alt] = {}
            if (not origNumber in functionInjectNumberMap[alt]):
               functionInjectNumberMap[alt][origNumber] = highestByType[alt] + 1
               highestByType[alt] += 1
               
            number = functionInjectNumberMap[alt][origNumber]
            newFunc = alt + str(number) + re.search('[^\d]*$', func).group(0)
            extraFuncs.add(newFunc)
            functionChildren[func].add(newFunc)

   
   functions |= extraFuncs
   
   functionPins = {}
   functionPinAF = {}
   
   for func in functions:
      functionPins[func] = []
      functionPinAF[func] = {}
      
   for pin in root.iter("{http://mcd.rou.st.com/modules.php?name=mcu}GPIO_Pin"):
      pinName = pin.get("Name")
      if pinName.find('-')>=0:
         pinName = pinName.rsplit('-')[0]
      if (pinName.find('[')<0):
         for signal in pin.findall("{http://mcd.rou.st.com/modules.php?name=mcu}PinSignal"):
            funcName = signal.get("Name")
            functionPins[funcName].append(pinName)
            af = signal.find("{http://mcd.rou.st.com/modules.php?name=mcu}SpecificParameter").find("{http://mcd.rou.st.com/modules.php?name=mcu}PossibleValue").text
            afNum = af.rsplit("AF")[1].split("_")[0]
            functionPinAF[funcName][pinName] = afNum
            for alternate in functionChildren[funcName]:
               functionPins[alternate].append(pinName)
               functionPinAF[alternate][pinName] = afNum

   outputName = re.search('STM32[^_]*', sys.argv[i])
   outputName = outputName.group(0)+".h"
   with open(outputName, "w") as out:
      name = re.search('STM32[^_]*', sys.argv[i])
      name = name.group(0)
      out.write("/*\n  * This file is automatically generated by afTable.py from the xml descriptions provided as part of the STM32Cube IDE\n*/\n\n")
      out.write("#ifndef LOWLEVEL_INCLUDE_DEVICE_ALTERNATE_FUNCTION\n")
      out.write("#define LOWLEVEL_INCLUDE_DEVICE_ALTERNATE_FUNCTION\n\n")
      for func in sorted(functions):
         for pin in functionPins[func]:
            out.write("#define "+func+"_"+pin+"_ "+pin+",GPIO_AF"+str(functionPinAF[func][pin])+"\n");
         for pin in functionPins[func]:
            out.write("#define _"+func+"_"+pin+"_ 1\n");
         out.write('\n')
      out.write("#endif /* LOWLEVEL_INCLUDE_DEVICE_ALTERNATE_FUNCTION */")
      
      
      
